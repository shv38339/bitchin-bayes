---
title: "Sports Analytics Using Bayesian Methods"
author: "Tom Jeon and Steele Valenzuela"
date: "April 26, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction:
The recent explosion of Fantasy Sports engendered many sports fans to rely on hard truths based on real data.  When sports fanatics and statistics mesh, betting and gambling on who will win a game become the most salient information.  The most common way sports analysts go about this is to train models that directly estimate the probability of a win;  however, considering very close games or blowouts, there’s a lot of information in the score differential that is disregarded if only the outcome of the game is modeled.  In this report, we use Bayesian methods to model expected score differential for the Boston Celtics, using data from 2004 to 2016.
We explore time series and spline regression in the Bayesian framework to answer the following questions.  Who is a better head coach, Doc Rivers, the former head coach of the Boston Celtics from 2004 to 2013, or Brad Stevens, the current head coach?  What is the expected score differential for the next Celtics game?  How does the expected score differential change if given the opposing team’s ranking?   

## Data:
The data we collected from sports-reference.com included the final score records of all games from 2004 to 2016, and team rankings for each corresponding year.  We subsetted for when the Boston Celtics were either the Home Team or the Visiting Team and then calculated the score differential for each game, then assigned each observation the ranking of the opposing team for each season.


```{r, echo = FALSE, message = FALSE, warning = FALSE}
ult <- read.csv("ult.csv")
doc <- read.csv("doc.csv")
brad <- read.csv("brad.csv")

library(dplyr)
ult$Date <- as.Date(ult$Date, format = "%a, %b %d, %Y")
ult2 <- arrange(ult, by = Date)
ult2 <- ult2[,-c(1:2)]
library(knitr)
kable(head(ult2, 10))
```

Because many separate attributes about the team and its players were aggregated to calculate the rankings of each team, we decided the data we had were sufficient.  The opposing teams' rankings for each season were based on the previous season's data.  

## Exploratory Analysis

The first graph shows the score differential between the Celtics and their opponent at the end of every game from 2004 to 2016.  This means that because there were multiple games between the Celtics and the 1 to 30 ranked teams, there are many y values per x value.  Here, we defined a positive score differential to mean that the Celtics had a higher score at the end of the game and won.  

```{r, echo = FALSE, warning=FALSE, message=FALSE}
x.i <- ult$Rk
y.i <- ult$diff

plot(x.i, y.i, ylab = "Score Differential", xlab = "Ranking of Opponnent at Respective Year", main = "Boston Celtics Season '04-'16")
```

Next we looked the score differentials as a function of time to explore whether it was appropriate to use an AR(1) model for the score differentials.  

```{r, echo = FALSE, warning = FALSE, message = FALSE}
ult$Date <- as.Date(ult$Date, format = "%a, %b %d, %Y")
ult2 <- arrange(ult, by = Date)

Differential <- ult2$diff
plot(Differential, type = "l", main = "Score Differential Boston Celtics 2004-2016", ylab = "Score Differential", xlab = "Game #")
```

The data looks stationary, with no obvious heteroskedastic qualities.  To see if there were any correlation between the current and previous games' score differentials, we plotted an autocorrelation function for this data.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(TSA)
acf(Differential)
```

Looks like there are significant correlations between previous games and the current one! An AR(1) process to model the score differentials seems appropriate for our data.

## Analytics
### Doc Rivers vs. Brad Stevens
One question we can answer using this data is, who is a better head coach, Doc Rivers or Brad Stevens?  We approached this question by fitting two Bayesian B-splines models, one with the data for when Doc Rivers was head coach, and one for Brad Stevens.  

Here is the model set up:

$$y_{i} \sim N(\mu_{i}, \sigma_{i}^2)$$
$$\mu_{i} \sim \sum_{k=1}^{K}\left(b_{k}(x_{i}) \right)$$

With priors:
$$\alpha_{k} \sim N(0, 100)$$ 
$$\sigma_{y} \sim U(0, 3)$$

Spline intervals and degree:
$$ I = 2.5$$
$$ degree = 3$$

To easily compare our splines models, we plotted both models on the same graph as shown below.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(splines)
library(dplyr)
library(rjags)
library(R2jags)
# Functions defined
GetSplines <- function( # Get B-splines
    x.i, ##<< Vector of x-values (without NAs) for which splines need to be calculated (determines the number of rows of B.ik)
    x0 = NULL, ##<< x-value which determines knot placement. By default, knot is placed half-interval before last observation
    I = 2.5, ##<< Interval length between two knots during observation period
    degree = 3 # currently tested only with degree 3
) {
    if (is.null(x0)) {
        x0 <- max(x.i)-0.5*I 
    } 
    # get knots, given that one knot needs to be in year0
    knots <- seq(x0-1000*I, x0+1000*I, I) 
    while (min(x.i) < knots[1]) knots <- c(seq(knots[1]-1000*I, knots[1]-I,I), knots)
    while (max(x.i) > knots[length(knots)]) knots <- c(knots, seq(knots[length(knots)]+I, 
                                                                  knots[length(knots)]+1000*I, I)) 
    Btemp.ik <- bs(x.i, knots = knots[-c(1, length(knots))],  degree = degree,
                   Boundary.knots = knots[c(1, length(knots))])
    indicesofcolswithoutzeroes <- which(apply(Btemp.ik, 2, sum) > 0)
    # only remove columns with zeroes at start and end
    startnonzerocol <- indicesofcolswithoutzeroes[1]
    endnonzerocol <- indicesofcolswithoutzeroes[length(indicesofcolswithoutzeroes)]
    B.ik <- Btemp.ik[,startnonzerocol:endnonzerocol]
    colnames(B.ik) <- paste0("spline", seq(1, dim(B.ik)[2]))
    knots.k <- knots[startnonzerocol:endnonzerocol]
    names(knots.k) <- paste0("spline", seq(1, dim(B.ik)[2]))
    ##value<< List of B-splines containing:
    return(list(B.ik = B.ik, ##<< Matrix, each row is one observation, each column is one B-spline.
                knots.k = knots.k ##<< Vector of knots.
    ))
}

#Adding CIs to plot {graphics}
AddCIs <- function(CI.low.t, # lower bound for seq.years.t
                   CI.up.t, # upper bound for seq.years.t
                   seq.years.t, col = 1){
    # add CIs to a plot.
    col = adjustcolor(col, alpha.f = 0.1)
    for (t in 2:length(seq.years.t))
        polygon(c(seq.years.t[t-1], seq.years.t[t-1], seq.years.t[t], seq.years.t[t],seq.years.t[t-1]),
                c(CI.low.t[t-1], CI.up.t[t-1], CI.up.t[t], CI.low.t[t], CI.low.t[t-1]),
                col=col, border = NA)
}

n <- length(y.i)

I <- 5 # between-knot length
res <- GetSplines(x.i, I = I)
B.ik <- res$B.ik

K <- dim(B.ik)[2]
parnames <- c("alpha.k", "mu.i", "sigma.y")
jags.data <- list(B.ik = B.ik, y.i = y.i, n=n, K=K)
mod <- jags.parallel(jags.data,
                     parameters.to.save = parnames, 
                     model.file="splines_model_notpenalized.txt")

# obtaining estimates for all x
# use the alphas to evaluate the result at any grid of values
alpha.sk <- mod$BUGSoutput$sims.list[["alpha.k"]]
# define grid, here indexed with .t
xgrid.t <- seq(min(x.i), max(x.i), 1)
ngrid <- length(xgrid.t)
# and use the same splines by keeping I and x0 fixed,
# evaluate splines at grid of xs
res2 <- GetSplines(xgrid.t, I = I, x0 = max(x.i)-0.5*I)
CI.qt <- matrix(NA, 3,ngrid)
for (t in 1:ngrid){  
    CI.qt[,t] <- quantile(res2$B.ik[t,]%*%t(alpha.sk),c(0.025, 0.5, 0.975))
}

set.seed(123)
# Doc Rivers
x.i_doc <- doc$Rk
y.i_doc <-  doc$diff
n_doc <- length(y.i_doc)

res_doc <- GetSplines(x.i_doc, I = I)
B.ik_doc <- res_doc$B.ik

K_doc <- dim(B.ik_doc)[2]
parnames <- c("alpha.k", "mu.i", "sigma.y")
jags.data <- list(B.ik = B.ik_doc, y.i = y.i_doc, n=n_doc, K=K_doc)
mod_doc <- jags.parallel(jags.data,
                     parameters.to.save = parnames, 
                     model.file="splines_model_notpenalized.txt")

# obtaining estimates for all x
# use the alphas to evaluate the result at any grid of values
alpha.sk_doc <- mod_doc$BUGSoutput$sims.list[["alpha.k"]]
# define grid, here indexed with .t
xgrid.t_doc <- seq(min(x.i_doc), max(x.i_doc), 1)
ngrid_doc <- length(xgrid.t_doc)
# and use the same splines by keeping I and x0 fixed,
# evaluate splines at grid of xs
res2_doc <- GetSplines(xgrid.t_doc, I = I, x0 = max(x.i_doc)-0.5*I)
CI.qt_doc <- matrix(NA, 3,ngrid_doc)
for (t in 1:ngrid_doc){  
    CI.qt_doc[,t] <- quantile(res2_doc$B.ik[t,]%*%t(alpha.sk_doc),c(0.025, 0.5, 0.975))
}



# Brad Stevens
x.i_brad <- brad$Rk
y.i_brad <- brad$diff
n_brad <- length(y.i_brad)

res_brad <- GetSplines(x.i_brad, I = I)
B.ik_brad <- res_brad$B.ik

K_brad <- dim(B.ik_brad)[2]
parnames <- c("alpha.k", "mu.i", "sigma.y")
jags.data <- list(B.ik = B.ik, y.i = y.i_brad, n=n_brad, K=K_brad)
mod_brad <- jags.parallel(jags.data,
                         parameters.to.save = parnames, 
                         model.file="splines_model_notpenalized.txt")

# obtaining estimates for all x
# use the alphas to evaluate the result at any grid of values
alpha.sk_brad <- mod_brad$BUGSoutput$sims.list[["alpha.k"]]
# define grid, here indexed with .t
xgrid.t_brad <- seq(min(x.i_brad), max(x.i_brad), 1)
ngrid_brad <- length(xgrid.t_brad)
# and use the same splines by keeping I and x0 fixed,
# evaluate splines at grid of xs
res2_brad <- GetSplines(xgrid.t_brad, I = I, x0 = max(x.i_brad)-0.5*I)
CI.qt_brad <- matrix(NA, 3,ngrid_brad)
for (t in 1:ngrid_brad){  
    CI.qt_brad[,t] <- quantile(res2_brad$B.ik[t,]%*%t(alpha.sk_brad),c(0.025, 0.5, 0.975))
}
y.i <- ult$diff
par(lwd = 1, mfrow = c(1,1))
plot(x.i, y.i, ylab = "Score Differential", xlab = "Ranking of Opponnent at Respective Year", main = "Boston Celtics Season '04-'16")
lines(CI.qt_doc[2,] ~ xgrid.t_doc, col = "red")
lines(CI.qt_brad[2,] ~ xgrid.t_brad, col = "blue")
abline(h=0)

lines(CI.qt[2, ]~xgrid.t, col = "green")
legend("topleft", legend = c("Doc Rivers", "Brad Stevens", "Overall"), col = c("red", "blue", "green"), lty = 1)
```

As expected, the green spline model which represents the whole data regardless of whether the Boston Celtics were coached under Doc Rivers or Brad Stevens shows there is an upward trend as the ranking of the opposing team increases.  That is, the Celtics seem to do better against teams that are ranked lower.  A similar trend follows the red spline model, which represents Celtics performance under Doc Rivers, except it is slightly above the green one, which suggests that under Doc Rivers, the Celtics performed better than how the Celtics performed with and without Doc Rivers.  Now if you look at the blue line, the spline model that represents Celtics' performance under the current head coach, Brad Stevens, there is a downward trend!  This suggests that under Brad Stevens, the Celitcs do better against teams that are ranked higher.  We thought this revealed a lot about Stevens' coaching style.  

To have a quantitative way of comparing the two head coaches, we looked at the area under the splines curves for Rivers and Stevens (red and blue) and over the horizontal line at $y = 0$.  Once we do so, we can effectively conclude that the Celtics performed better under Doc Rivers and hence Rivers is the superior coach, holding all other variables constant.  

### Time Series

